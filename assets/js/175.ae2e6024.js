(window.webpackJsonp=window.webpackJsonp||[]).push([[175],{474:function(t,a,s){"use strict";s.r(a);var r=s(4),_=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"缓存穿透、缓存击穿、缓存雪崩的场景以及解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透、缓存击穿、缓存雪崩的场景以及解决方法"}},[t._v("#")]),t._v(" 缓存穿透、缓存击穿、缓存雪崩的场景以及解决方法")]),t._v(" "),a("blockquote",[a("p",[t._v("作者："),a("a",{attrs:{href:"https://github.com/lhccong",target:"_blank",rel:"noopener noreferrer"}},[t._v("聪ζ"),a("OutboundLink")],1),t._v("，"),a("a",{attrs:{href:"https://wx.zsxq.com/dweb2/index/group/51122858222824",target:"_blank",rel:"noopener noreferrer"}},[t._v("编程导航星球"),a("OutboundLink")],1),t._v(" 编号 12852")])]),t._v(" "),a("h3",{attrs:{id:"都是缓存惹的祸"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#都是缓存惹的祸"}},[t._v("#")]),t._v(" 都是缓存惹的祸")]),t._v(" "),a("p",[t._v("在项目开发中，我们的数据都是要持久化到磁盘中去，比如使用 MySQL 进行持久化存储，但是呢由于流量越来越大，查询速度也逐渐变慢了起来，于是我们决定！使用缓存！然而使用缓存导致会经常面临三座大山！缓存穿透！！缓存击穿！！缓存雪崩！！，接下来我们将会逐一分析他们导致的原因以及解决方法。")]),t._v(" "),a("h3",{attrs:{id:"缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[t._v("#")]),t._v(" 缓存雪崩")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202404220839636.png",loading:"lazy"}})]),t._v(" "),a("h4",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("缓存雪崩是指在某个时间点，大量缓存同时失效或被清空，导致大量请求直接打到数据库或后端系统，造成系统负载激增，甚至引发系统崩溃。这通常是由于缓存中的大量数据在同一时间失效引起的。想象一个在线电商系统，用户访问频繁，需要频繁查询商品信息。假设某一系列的商品突然全部同一时间失效，那就会造成我们的缓存雪崩。或者某一个时刻 Redis 缓存中间件故障了，导致服务全部打到了数据库，也会导致缓存雪崩的情况。")]),t._v(" "),a("h4",{attrs:{id:"解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[t._v("#")]),t._v(" 解决办法")]),t._v(" "),a("p",[t._v("缓存键同时失效：")]),t._v(" "),a("p",[t._v("1）过期时间随机化：设置缓存的过期时间，加上一个随机值，避免同一时间大量缓存失效。")]),t._v(" "),a("p",[t._v("2）使用多级缓存：引入多级缓存机制，如本地缓存和分布式缓存相结合，减少单点故障风险。")]),t._v(" "),a("p",[t._v("3）缓存预热：系统启动时提前加载缓存数据，避免大量请求落到冷启动状态下的数据库。")]),t._v(" "),a("p",[t._v("4）加互斥锁：保证同一时间只有一个请求来构建缓存，别的只能等它构建完成再从缓存中读取。")]),t._v(" "),a("p",[t._v("缓存中间件故障：")]),t._v(" "),a("p",[t._v("1）服务熔断：暂停业务的返回数据，直接返回错误。")]),t._v(" "),a("p",[t._v("2）构建集群：构建多个 Redis 集群保证其高可用。")]),t._v(" "),a("h3",{attrs:{id:"缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[t._v("#")]),t._v(" 缓存击穿")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202404220840108.png",loading:"lazy"}})]),t._v(" "),a("h4",{attrs:{id:"介绍-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍-2"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("缓存击穿是指针对某一热点数据的大量请求导致缓存失效，进而直接请求数据库，增加数据库负载。这种情况通常发生在某个特定的缓存 key 在失效时，恰好有大量请求到达。想象一下大家都在抢茅台，但在某一时刻茅台的缓存失效了，大家的请求打到了数据库中，这就是缓存击穿，那他跟缓存雪崩有什么区别呢？缓存雪崩是多个 key 同时，缓存击穿是某个热点 key 崩溃。也可以认为缓存击穿是缓存雪崩的子集。")]),t._v(" "),a("h4",{attrs:{id:"解决办法-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决办法-2"}},[t._v("#")]),t._v(" 解决办法")]),t._v(" "),a("p",[t._v("1）加互斥锁：保证同一时间只有一个请求来构建缓存，别的只能等它构建完成再从缓存中读取。跟缓存雪崩相同。")]),t._v(" "),a("p",[t._v("2）永久：不要给热点数据设置过期时间。")]),t._v(" "),a("h3",{attrs:{id:"缓存穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[t._v("#")]),t._v(" 缓存穿透")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202404220840125.png",loading:"lazy"}})]),t._v(" "),a("h4",{attrs:{id:"介绍-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍-3"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("缓存穿透是指查询一个不存在的数据，由于缓存和数据库中均不存在，导致每次请求都直接访问数据库，增加数据库负载。攻击者可以通过构造不存在的 key 发起大量请求，造成系统宕机。比如有些小黑子对于我们开发的网站进行恶意的请求，将一些数据库不存在的 ID 疯狂的打在我们的服务器上，如果没做好缓存穿透的预防，还真给你们小黑子得逞了。")]),t._v(" "),a("h4",{attrs:{id:"解决办法-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决办法-3"}},[t._v("#")]),t._v(" 解决办法")]),t._v(" "),a("p",[t._v("1）防止非法请求：检查非法请求，封禁其 IP 以及账号，防止它再次为非作歹。。")]),t._v(" "),a("p",[t._v("2）缓存空值：允许缓存空值或者可以给他一个默认值。")]),t._v(" "),a("p",[t._v("3）使用布隆过滤器：通过布隆过滤器给数据做一个标记，当发生缓存穿透时也不会请求数据库造成压力，直接通过布隆过滤器和 Redis 判断返回。")])])}),[],!1,null,null,null);a.default=_.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[328],{633:function(t,s,a){"use strict";a.r(s);var n=a(4),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"你真的会写单例模式么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你真的会写单例模式么"}},[t._v("#")]),t._v(" 你真的会写单例模式么？")]),t._v(" "),s("blockquote",[s("p",[t._v("本文作者："),s("a",{attrs:{href:"https://yuyuanweb.feishu.cn/wiki/Abldw5WkjidySxkKxU2cQdAtnah",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序员鱼皮"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("本站地址："),s("a",{attrs:{href:"https://codefather.cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://codefather.cn"),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("设计模式是开发岗面试中的高频考点，在设计模式中，"),s("strong",[t._v("单例模式基本是必考的！")])]),t._v(" "),s("p",[t._v("为什么面试官爱问单例模式呢？原因如下：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("单例模式是我们平时编程中最常用的设计模式之一。")])]),t._v(" "),s("li",[s("p",[t._v("单例模式实现简单，不会占用太多面试时间")])]),t._v(" "),s("li",[s("p",[t._v("单例模式的实现有很多种，而且有优劣之分，能够体现面试者的基本功和水平。")])])]),t._v(" "),s("p",[t._v("即使是工作几年的程序员，也未必能完全正确地手写单例模式，实现方式也不完全相同。")]),t._v(" "),s("p",[t._v("那么你真的会写单例模式么？")]),t._v(" "),s("p",[s("strong",[t._v("什么是单例模式？")])]),t._v(" "),s("p",[t._v("单例模式是OOP（面向对象编程）语言的一种概念，顾名思义，就是一个类只能有一个实例对象。")]),t._v(" "),s("p",[t._v("单例模式又分为懒汉式单例和饿汉式单例， 下面介绍两种方式的传统实现及优化后的推荐实现（本来想叫“最佳实现”，但网上实现方式太多，比如乐观锁、枚举类等等，就不给自己留坑了）。")]),t._v(" "),s("p",[s("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311071352585.png",loading:"lazy"}})]),t._v(" "),s("h3",{attrs:{id:"懒汉式单例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#懒汉式单例"}},[t._v("#")]),t._v(" "),s("strong",[t._v("懒汉式单例")])]),t._v(" "),s("p",[t._v("懒汉式单例的特点是：当需要使用对象的时候才进行实例化。")]),t._v(" "),s("p",[t._v("由于可能有多个线程同时要使用对象，因此需要考虑线程安全问题，防止并发访问时生成多个实例。通常需要加锁来解决并发冲突，是用时间来换空间的方案。")]),t._v(" "),s("h4",{attrs:{id:"传统实现代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传统实现代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("传统实现代码：")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Singleton{    // 私有构造函数    \n\tprivate Singleton() {}     \n\tprivate static Singleton obj;     \n\t// 加锁保证obj只实例化一次，时间换空间    \n\tpublic static synchronized Singleton getInstance(){        \n\tif (obj == null) {            \n\tobj = new Singleton();        \n\t}        \n\treturn obj;    \n\t}\n}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("传统实现方式中，每次获取实例都要被synchronized关键字串行化，即使已经生成了对象实例。")]),t._v(" "),s("p",[t._v("而我们加锁的目的是为了防止生成多个实例，因此只需对生成实例的代码加锁，生成实例后，可支持并发访问，提高了性能。")]),t._v(" "),s("p",[s("strong",[t._v("优化后的代码：")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Singleton {    \n// 私有构造函数    \nprivate Singleton() {}    \n// 最后解释volatile关键字    \nprivate volatile static Singleton obj;    \npublic static Singleton getInstance(){        \n// 已有实例则直接返回，不走锁        \nif (obj == null) {            \n// 仅在没生成实例时加锁控制，使并发访问串行化            \nsynchronized (Singleton.class) {                \n// 多个线程会按序执行到此处，需要再次检查是否已实例化                \nif (obj == null) {                   \nobj = new Singleton();               \n}            \n}        \n}        \nreturn obj;    \n}\n}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br")])]),s("p",[t._v("在上述代码中，由于检查了两次对象是否已实例化，因此该方法又称**“双检锁”**，能够保证线程安全的同时提升对象实例化后的调用性能。")]),t._v(" "),s("h3",{attrs:{id:"饿汉式单例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#饿汉式单例"}},[t._v("#")]),t._v(" "),s("strong",[t._v("饿汉式单例")])]),t._v(" "),s("p",[t._v("饿汉式单例的特点是：类加载时便实例化对象。")]),t._v(" "),s("p",[t._v("能够在第一时间实例化对象，供其他方法使用，是拿空间换时间的方案。")]),t._v(" "),s("h4",{attrs:{id:"传统实现代码-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传统实现代码-2"}},[t._v("#")]),t._v(" "),s("strong",[t._v("传统实现代码：")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Singleton{    // 私有构造函数    private Singleton() {}    // 类加载时就实例化对象    private static Singleton obj = new Singleton();         public static Singleton getInstance(){        return obj;    }}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h4",{attrs:{id:"通过static关键字-在类加载时创建对象。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过static关键字-在类加载时创建对象。"}},[t._v("#")]),t._v(" 通过static关键字，在类加载时创建对象。")]),t._v(" "),s("h4",{attrs:{id:"优化实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化实现"}},[t._v("#")]),t._v(" "),s("strong",[t._v("优化实现")])]),t._v(" "),s("p",[t._v("上述传统实现方式中，由于类加载时就实例化对象，因此当我们调用这个类的其他静态方法时，也会触发类加载，从而实例化单例对象，会导致空间的暂时浪费。")]),t._v(" "),s("p",[t._v("由于静态内部类中的对象不会默认加载，直到调用了获取该内部类属性的方法。因此可用静态内部类封装静态实例变量。")]),t._v(" "),s("p",[s("strong",[t._v("优化后的代码：")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Singleton{    // 私有构造函数    private Singleton() {}     // 静态内部类    private static class SingletonHolder {        private static Singleton instance = new Singleton();    }    public static Singleton getInstance(){        return SingletonHolder.instance;    }}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("上面种种实现方式中，最推荐这种优化后的饿汉式实现，利用static保证线程安全，利用静态内部类节约了空间，实现lazy-loading（懒加载），而且代码非常简短，可谓一箭三雕。")]),t._v(" "),s("p",[t._v("接下来我们深入分析下单例模式代码中的细节。")]),t._v(" "),s("h3",{attrs:{id:"单例模式细节深入分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单例模式细节深入分析"}},[t._v("#")]),t._v(" "),s("strong",[t._v("单例模式细节深入分析")])]),t._v(" "),s("p",[t._v("虽然懒汉式单例优化版的实现代码相对复杂，但是有一些细节值得学习和考究。")]),t._v(" "),s("p",[t._v("比如这行声明实例的代码中为什么要使用volatile关键字？")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("private volatile static Singleton obj;\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("看似不起眼的volatile关键字，如果不添加的话，可能出现获取实例为null的情况！")]),t._v(" "),s("p",[t._v("为什么呢？")]),t._v(" "),s("p",[t._v("因为使用new来创建对象不是一个原子操作（不可分割的操作序列，要么都成功，要么都失败），而是会被编译成如下三条指令：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("给实例分配内存")])]),t._v(" "),s("li",[s("p",[t._v("初始化实例的构造")])]),t._v(" "),s("li",[s("p",[t._v("将实际对象指向分配的内存空间（此时实例应该已经不为空）")])])]),t._v(" "),s("p",[t._v("正常的思路是123一定按顺序执行。")]),t._v(" "),s("p",[t._v("但事实上，Java会对进行指令重排序。")]),t._v(" "),s("blockquote",[s("p",[t._v("JVM根据处理器的特性，充分利用多级缓存，多核等进行适当的指令重排序，使程序在保证业务运行的同时，充分利用CPU的执行特点，最大的发挥机器的性能。")])]),t._v(" "),s("p",[t._v("即JVM虚拟机在执行上面三条指令时，可能按照132的顺序执行。")]),t._v(" "),s("p",[t._v("假设当13执行完，2还未执行时，如果另外一个线程调用getInstance()，会在判断对象是否为null时返回false（因为3已执行，对象指向了内存空间，已不为空），然后直接返回实例。但由于此时2还没执行，实例并未完全初始化，只是分配了内存空间，就会导致使用对象时出现错误（引用逃逸）。")]),t._v(" "),s("p",[s("strong",[t._v("注意：final字段不能保证初始化过程中的可见性，也无法禁止指令重排序！")])]),t._v(" "),s("p",[t._v("而voliate关键字可以通过内存屏障禁止指令重排序，保证创建对象时的123步骤按顺序执行，从而解决上述问题。")]),t._v(" "),s("p",[s("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311071352274.jpeg",loading:"lazy"}})]),t._v(" "),s("p",[s("strong",[t._v("写在最后")])]),t._v(" "),s("h3",{attrs:{id:"其实单例模式还有其他的实现方式-比如spring容器的单例实现-用局部变量避免指令重排序来提高性能-一种特殊的避免指令重排序的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其实单例模式还有其他的实现方式-比如spring容器的单例实现-用局部变量避免指令重排序来提高性能-一种特殊的避免指令重排序的方法"}},[t._v("#")]),t._v(" 其实单例模式还有其他的实现方式，比如spring容器的单例实现，用局部变量避免指令重排序来提高性能（一种特殊的避免指令重排序的方法）：")]),t._v(" "),s("p",[s("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311071352297.jpeg",loading:"lazy"}}),t._v("Spring还有一种单例的登记式注册表实现，有兴趣的同学可以自行搜索。")])])}),[],!1,null,null,null);s.default=e.exports}}]);
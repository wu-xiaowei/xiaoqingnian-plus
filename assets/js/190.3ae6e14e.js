(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{491:function(t,a,s){"use strict";s.r(a);var v=s(4),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"带老弟做个实时排行榜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#带老弟做个实时排行榜"}},[t._v("#")]),t._v(" 带老弟做个实时排行榜")]),t._v(" "),a("blockquote",[a("p",[t._v("本文作者："),a("a",{attrs:{href:"https://yuyuanweb.feishu.cn/wiki/Abldw5WkjidySxkKxU2cQdAtnah",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序员鱼皮"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("本站地址："),a("a",{attrs:{href:"https://codefather.cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://codefather.cn"),a("OutboundLink")],1)])]),t._v(" "),a("blockquote",[a("p",[t._v("阿巴可懂的实时排行榜设计和实现思路。")])]),t._v(" "),a("p",[t._v("大家好，我是鱼皮，暑假快到了，我的老弟小阿巴听说我家有很多好康的，就跑来找我玩。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829973.jpeg",loading:"lazy"}})]),t._v(" "),a("p",[t._v("结果我摆出了几个以前开发过的小系统，准备在这段时间带着小阿巴多做些作品，学习编程项目的设计思路。这样等他开学了，就可以更轻松地跟着老师做做项目了。")]),t._v(" "),a("p",[t._v("今天，就先带他做一个很常见的小功能：用户实时积分排行榜。")]),t._v(" "),a("h2",{attrs:{id:"实时积分排行榜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实时积分排行榜"}},[t._v("#")]),t._v(" 实时积分排行榜")]),t._v(" "),a("h3",{attrs:{id:"需求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),a("p",[t._v("先描述下需求，在我的编程导航项目中，为了鼓励大家共同维护网站，用户可以通过推荐资源、积极评论、举报违规资源等方式获取积分。")]),t._v(" "),a("p",[t._v("为了进一步激励大家，网站需要提供一个用户积分排行榜，分为 "),a("strong",[t._v("实时总积分榜")]),t._v(" 、 "),a("strong",[t._v("周榜")]),t._v(" 和 "),a("strong",[t._v("月榜")]),t._v("，均 "),a("strong",[t._v("只取前 10 名")]),t._v(" 。所有用户都能够查看当前排行榜，以及查看自己的 "),a("strong",[t._v("实时")]),t._v(" 总积分排名，后续管理员就可以给上榜用户颁发奖品了。")]),t._v(" "),a("p",[t._v("效果如下图：")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829134.png",loading:"lazy"}})]),t._v(" "),a("p",[t._v("点击 "),a("code",[t._v("我的排名")]),t._v(" 按钮，可以查看自己的实时排名：")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829012.png",loading:"lazy"}})]),t._v(" "),a("p",[t._v("本文篇幅有限，先仅讨论 "),a("strong",[t._v("实时总积分榜")]),t._v(" 的设计实现。")]),t._v(" "),a("p",[t._v("听了需求后，小阿巴爽朗一笑：这有啥难的？且让我设计一波，再给你娓娓道来。")]),t._v(" "),a("h3",{attrs:{id:"设计实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计实现"}},[t._v("#")]),t._v(" 设计实现")]),t._v(" "),a("p",[t._v("先看下数据库的结构，总共有 2 个表："),a("strong",[t._v("用户表")]),t._v(" 和 "),a("strong",[t._v("用户积分表")]),t._v("。")]),t._v(" "),a("p",[t._v("用户表存储了用户信息，以及用户的总积分（实时更新），也就是说总积分榜需要的数据可以直接从这里取到，不需要再去计算。")]),t._v(" "),a("p",[t._v("用户表内容：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("用户 id")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("用户名")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("积分（score）")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("1")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("小阿巴")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("10")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("2")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("李鱼皮")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("1000")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("3")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("小李")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("100")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("......")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}}),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("100")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("李老热")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("66")])])])]),t._v(" "),a("p",[t._v("如果要取前 10 名，只需要把所有用户的信息先取出来，再排个序就好啦，写 SQL 语句查询的话就是：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("select * from `user` order by score;\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("然后如果要取自己的总排名，就对查到的有序数据进行一次遍历，找到自己所在的位置下标就行，伪代码如下：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 从数据库查询全部用户列表\nlist = getAllDataList()\nfor(i = 0; i < total; i++) {\n  // 找到自己的位置\n  if(list[i].id == '我的id') {\n    return i + 1;\n  }\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("小阿巴得意到：这不就实现总积分榜了么？你这需求太简单，啧啧。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829089.png",loading:"lazy"}})]),t._v(" "),a("p",[t._v("我笑到：还不错，总积分榜的思路是正确的，起码知道要对所有的数据进行排序。但如果用户数特别多呢？比如几十万个，你只需要查自己的总排名，还需要把全部的数据都做一个排序么？")]),t._v(" "),a("p",[t._v("小阿巴陷入沉思，想了半天，没想出来。")]),t._v(" "),a("p",[t._v("于是我提示到：假如在一次考试中你想知道自己的排名，是不是只需要知道有多少人的分数比自己高就行了，不用去管其他人排第几对吧？")]),t._v(" "),a("p",[t._v("小阿巴一拍脑袋：对啊，我只需要先查出自己的分数，然后统计分数大于我的用户数量，不就知道自己的排名了？")]),t._v(" "),a("p",[t._v("先用 SQL 语句查出用户的分数：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('/* 只取需要的列 */\nselect score as myScore\nfrom `user`\nwhere id = "用户 id";\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("然后再用 SQL 语句统计分数大于该用户分数的数量：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("select count(*) from `user`\nwhere score > myScore;\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("最后只需要将该查询结果加 1，就是自己的排名啦~")]),t._v(" "),a("p",[t._v("小阿巴感叹到：原来转换一点点思路，就能省去多余的排序带来的性能开销，起飞~")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829113.png",loading:"lazy"}})]),t._v(" "),a("h3",{attrs:{id:"更多思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更多思考"}},[t._v("#")]),t._v(" 更多思考")]),t._v(" "),a("p",[t._v("鱼皮：先别起飞，其实对于一般用户量的系统，上面的方案就已经足够了。下面让我们加大难度，假如用户数再多一点点呢，比如说一亿个，怎么实时获取前 10 名呢？")]),t._v(" "),a("p",[t._v("小阿巴：还真是 “亿点点”，就您那破编程导航还想着有一亿个用户？")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829046.png",loading:"lazy"}})]),t._v(" "),a("p",[t._v("鱼皮：少废话，梦想还是要有的，万一有亿个用户呢？快想想系统怎么做！")]),t._v(" "),a("p",[t._v("小阿巴：且不说对一亿个数据排序有多慢，能不能存的下都是个问题啊。。。啊，等等，这难道就是面试常见的 Top N 问题！")]),t._v(" "),a("p",[t._v("鱼皮：不错，我面试的时候被问过好几次 Top N 问题，如何从海量数据中找出前 N 个数呢？")]),t._v(" "),a("p",[t._v("小阿巴：这我完全不懂啊，算法不会，真要命。")]),t._v(" "),a("p",[t._v("鱼皮：其实 Top N 问题的核心在于保证空间和时间复杂度，先要考虑数据能存入内存运算，在怎样算得更快。")]),t._v(" "),a("p",[t._v("通常 Top N 问题有下列几种解决方案。")]),t._v(" "),a("h4",{attrs:{id:"top-n-解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#top-n-解决方案"}},[t._v("#")]),t._v(" Top N 解决方案")]),t._v(" "),a("p",[a("strong",[t._v("全部排序")])]),t._v(" "),a("p",[t._v("直接对所有数据进行排序（快排等），缺点是需要将数据一次性加载到内存中。")]),t._v(" "),a("p",[a("strong",[t._v("局部淘汰")])]),t._v(" "),a("p",[t._v("内存中维护一个大小为 N 的容器，再让剩余的数一个个进入容器，并淘汰容器内的最小值。最终容器内剩下的数就是前 N 名。优点是能节省内存，缺点是太慢了。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829837.png",loading:"lazy"}})]),t._v(" "),a("p",[a("strong",[t._v("分治")])]),t._v(" "),a("p",[t._v("把数据分为多个小组，小组内先分别选出前 N 名小组长，最后再让这些小组长同台竞技，选出最终的前 N 名。")]),t._v(" "),a("p",[a("strong",[t._v("哈希预处理")])]),t._v(" "),a("p",[t._v("假如数据重复度很高，可以通过 hash 的方式，去掉很多重复数据。比如 1 亿个数据里，一半是 0，一半是 1，那么取前 10 名时，可以直接淘汰掉另一半为 0 的数据。")]),t._v(" "),a("p",[t._v("但是预处理本身也需要时间和空间，这就需要我们对数据的重复度有一个清晰的判断，否则自作聪明、适得其反。")]),t._v(" "),a("p",[a("strong",[t._v("小根堆")])]),t._v(" "),a("p",[t._v("面试算法中的高频考点 —— 堆排序，可以先取前 N 个数组成小根堆，堆顶始终是最小值。然后遍历后续数字，大于堆顶就替换掉堆顶并调整最小堆结构。该算法时间复杂度和空间复杂度（为 N，常数）都不错，所以必须要掌握。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829813.png",loading:"lazy"}})]),t._v(" "),a("p",[t._v("但是具体选择哪种方案呢？还是要结合我们实际的项目和业务场景来分析。")]),t._v(" "),a("h4",{attrs:{id:"实际解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实际解决"}},[t._v("#")]),t._v(" 实际解决")]),t._v(" "),a("p",[t._v("由于我们的数据库来记录积分，所以当用户量级很大时，首先要 "),a("strong",[t._v("分库分表")]),t._v(" ，通常是水平分表，根据一定规则（比如 id）把用户数据行分批存储在多个数据表中。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829954.png",loading:"lazy"}})]),t._v(" "),a("blockquote",[a("p",[t._v("分表")])]),t._v(" "),a("p",[t._v("然后就和大数据 Map / Reduce 处理机制一样了，可以采用 "),a("strong",[t._v("分治")]),t._v(" 的方式 "),a("strong",[t._v("并行计算")]),t._v(" 每个表的前 10 名（map），都计算好后，再汇总到一起计算最终的前 10 名（reduce）。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829190.png",loading:"lazy"}})]),t._v(" "),a("blockquote",[a("p",[t._v("一次大数据并行处理过程")])]),t._v(" "),a("p",[t._v("用这种方式，别说 1 亿了，2 亿、3 亿的计算模式都是一样的，加机器水平扩容就好了~")]),t._v(" "),a("p",[t._v("所以遇到 Top N 问题的时候，大家可以先答一下上面的几种方案，再结合具体的场景分析，分治和最小堆是我觉得相对 "),a("strong",[t._v("核心")]),t._v(" 的点。")]),t._v(" "),a("h4",{attrs:{id:"redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[t._v("#")]),t._v(" Redis")]),t._v(" "),a("p",[t._v("最后，对于实时排行榜的设计，肯定很多背过八股文面试题的朋友在第一时间会想到使用 Redis 的有序集合 zset，的确也是一种方案，但也要结合场景去分析利弊，不要秒答。")]),t._v(" "),a("p",[t._v("使用基于内存的 Redis zset 的确运算更快，且天然支持排序、使用方便。但数据量大时同样面临数据更新、维护、同步、持久化存储等问题，而且对于我们这种实时性要求不高的需求来说，有些大材小用了哈哈。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829118.png",loading:"lazy"}})]),t._v(" "),a("blockquote",[a("p",[t._v("zset 数据结构")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("我是鱼皮，周末肝文不易，如果觉得文章不错，希望 "),a("strong",[t._v("点赞 + 在看")]),t._v(" 支持下，给俺点创作动力。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pic.yupi.icu/5563/202311090829254.png",loading:"lazy"}})])])}),[],!1,null,null,null);a.default=_.exports}}]);